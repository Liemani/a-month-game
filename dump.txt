dump.txt
각종 개발 내용 기록

# index
dump: 생각을 마구 적음
일정: 대략적인 일정
issue: 이슈들
mandatory: 반드시 필요한 구현
finish: 완료한 항목
implementation: 구체적인 구현
bonus: 추가적으로 적용할 수도 있는 구현
dump log: 사용한 dump 내용을 쌓아둔다

# dump
2023-06-19
scene
    WorldScene
view controller
    WorldSceneViewController
view model
    WorldSceneViewModel
model
    WorldSceneModel
        SceneModel 이라는 단어가 ViewModel 로 해석될 여지가 있다

2023-06-18
service 는 비지니스 로직이 들어가는게 맞다면 내 model 이 service 가 되고
지금의 service 는 service 와 repository 의 중간 단계가 되야 할 것 같다

persistentContainer
    service
    repository
portalView
    PortalViewController
    view
        PortalScene
    viewModel
    model
worldView
    WorldViewController
    view
        WorldScene
    viewModel
    model

view model 을 view 와 model 사이에 둘 것인가?
view model 의 역할은 무엇인가?
두는게 좋겠는데?
지금 view 그리는데 막 로직들이 다 node 에 들어가서 불편하긴 했다
node 는 responder 의 역할만 하고
데이터는 view model 로 빼는게 좋겠다
view model 은 아하! field view model 이 field 를 가지고 있으면 되겠구나?

2023-06-17
만약 모델이 타일에 따라 바뀐다고 한다면
컨트롤러가 모델 변화에 따라 씬을 수정해줘야 할 것이다
메니지드 오브젝트는 어떤가?
매니지드 오브젝트는 필요에 따라 패치를 호출한다
그럼 컨트롤러도 필요에 따라 모델을 로드해 뷰를 그린다면?
만약 청크가 변한다면 그 때 뷰와 모델을 다 바꾸면 된다
굳이 서로 대화를 할 필요가 없다
하지만 이를 컨트롤러에서 처리한다면 부담이 크다
그럼 청크 변화를 처리하는 컨트롤러를 따로 둔다면?
캐릭터의 위치나 저장 로드 만들어보자

# 일정 및 진행 작업 기록
1주 2023-05-03 ~ 2023-05-09
계획 및 기초 개발
    2023-05-03 어떤 게임을 만들 것인지 구상
    2023-05-04 대략적인 기능 스케치
    2023-05-05
    2023-05-06 game object 및 앱 간단히 실행해보기
    2023-05-07 isWalkable 에 따른 캐릭터 이동 구현
    2023-05-08 간단한 데이터 모델과 저장, 초기화 기능 추가
    2023-05-09 게임 모델 구체화, 저장, 초기화 기능 구현

2주 2023-05-10 ~ 2023-05-16
베타 완료
    2023-05-10 DataController 추가
    2023-05-11 PortalScene 추가
    2023-05-12 WorldScene 에서 menu layer 추가
    2023-05-13 CoreData
    2023-05-14 save GameObject
    2023-05-15 remove GameObject
    2023-05-16 CoreData

3주 2023-05-17 ~ 2023-05-23
광고 추가, 컨텐츠 추가
    2023-05-17 DiskController
    2023-05-18 GameObjectDelegate, touch move
    2023-05-19 accessable object
    2023-05-20 collision
    2023-05-21 world border, reinforce touch
    2023-05-22
    2023-05-23

4주 2023-05-24 ~ 2023-05-30
리소스 생성, 테스트, 완성
    2023-05-24
    2023-05-25
    2023-05-26
    2023-05-27
    2023-05-28 정리
    2023-05-29 ppt 준비
    2023-05-30 마무리 

    2023-05-31 마감

# plan
## system
    quality
        모든 오브젝트는 품질이 있다
        초기 값은 0 이다
        제작 시 소모된 오브젝트 품질의 평균이 완성품의 품질이 된다.
        good 이면 +2, common 이면 +1, poor 이면 동일
        0, 10, 40, 90, 160, 250, 360, 1000
        기본, 1.1 배, 1.2 배, 1.3 배, 1.4 배
        1 + 0.1 * sqrt(품질 / 10)
    한국어와 영어 지원
    전파: 전파 리스트로 관리할 것
        잔디
        짧은 풀
        긴 풀
        나무: 주변 풀타일, 50 시간, life game 을 적용
        불: 인접한 타는 아이템
    light
        0 ~ 15
        태양은 15
        동
    touch
        interaction mode
            short touch
                - interaction
            drag
                - object move: 이동한 오브젝트는 스케일을 1.1 배로 키웠다가 다시 돌아오도록 피드백한다
                - object interaction
            long touch
                - inspect
        observation mode: 상호작용 모드랑 같지만 짧은 터치만 다르게 동작한다
            short touch
                - observe: 감각 메세지를 출력한다
    데이터 기록: 다양한 기록을 마스터리로 저장, 이동 거리와 플레이 타임도 저장한다
    상호작용은 액션 시간이 소모되지 않고 즉각 반응한다
    단, 일정 시간을 요구하는 비 상호작용 시스템이 존재한다
        나무가 자라는 시간, 벽돌이 구워지는 시간, 돌 스폰, 점토 스폰, 나무 스틱 스폰 등
    제작 창에 제작 가능한 오브젝트를 누르면 소모될 아이템이 강조된다
    이벤트 트리거 개발자 모드
    게임의 하루는 현실 12 시간
    시간에 따른 변화는 리스트를 만들어서 관리하자
    기껏 옮겨 왔는데 제자리로 돌아가는거는 좀 거지 같다
        역시 오브젝트는 무한대로 뭉칠 수 있게 하자
        이동 실패는 내 위치에 떨어지는거지
        근대 내 위치에 떨어지면 바로 주워 옮기기 좀 불편하네?
        그래도 일단 그게 최선이다
    character speed
        - 속도에 따라 발소리 빈도가 변한다
        shallow water: 0.25
        tall weed: 0.25
        short weed: 0.5
        dirt: 0.75
        paved tile: 1.0
    ground
        낮과 밤이 있다
    underground
        항상 어둡다
        입구는 태양만큼의 빛을 낸다
    고정 인벤토리의 id 는 유지하고 나무 같은 곳에 들어 있는 오브젝트의 위치는 인벤토리 id 에 해당 나무 id 값을 넣는거지
        나무의 인벤토리 칸도 제한을 둬서 상호작용하면 랜덤하게 하나의 인벤토리와 상호작용을 하게 되서 아이템이 적을수록 더 드랍이 안되는거지
    craft
        제작된 아이템을 필드에 바로 설치하지 못한 경우 우선 인벤토리로 들어가려고 시도한다. 만약 실패하면 열려 있는 컨테이너 인벤토리로 들어가려고 시도한다. 또 실패할 경우 현재 캐릭터 위치에 떨어뜨린다
    state bar: 각 오브젝트의 하단부에 2 pixel 정도 폭으로 게이지를 표시한다
        progress bar: 노란색
            pottery 의 진행도를 표시한다
            나무의 성장
            밀의 성장
        durability bar: 초록색
            내구도가 닳은 경우 표시한다
    fire: 1m 에 10 데미지를 입힌다
        불이 붙은 오브젝트에 화염 데미지를 입힌다. 화염 데미지를 입지 않는 오브젝트는 내구도가 닳지 않는다
    reclamation
        덩굴이 붙은 오브젝트에 데미지를 입힌다
### animation
    포탈 씬에서 월드 씬으로 이동할 때 꿈 속에 들어가는 것 처럼 최면을 거는 듯이 fade out fade in(시청각), 빨려 들어가는 음악
### event: 리스트로 관리
    reclamation: 데미지는 5 이다
        풀이 생성된 지 7 일이 지났고 주변에
            잔디 타일이 생성된 지 7 일이 지났다면 조건을 만족하는 주변 8 타일로 전부 퍼진다
            흙 타일이 생성된 지 7 일이 지났다면 조건을 만족하는 주변 타일을 잔디 타일로 바꾼다
            주변에 오브젝트가 있다면 데미지를 입힌다
        나무가 생성된 지 7일이 지났고 주변에
            나무는 퍼지기는 하는데 파괴하지는 않는다
            풀 타일이 생성된 지 7 일이 지났다면 조건을 만족하는 주변 타일 중 하나에 나무를 생성한다
    아이템 소실: 자연 타일 위에 있는 아이템이 생성된지 1 분이 지났고, 자연타일도 생성된지 1 분이 지났다면 오브젝트를 삭제한다
    현실 아침 6 시: sand, wood stick 재고 + 1
    지하 돌, 광물 세트: 템플릿을 만들어두고 충분한 공간이 있는 곳에 생성. 만약 랜덤하게 선택된 공간에 생성이 불가능하다면 실패. 만약 생성에 성공했다면 해당 위치에 있던 오브젝트를 삭제한다. 2/3 로 구리, 1/3 로 철. + 모양으로 5개에 주변을 한 겹 돌이 감싸는 형태
    grass, sapling, flower, vine, tall weed, short weed, crop 세트: 템플릿을 만들어두고 충분한 공간이 있는 곳에 생성. 만약 랜덤하게 선택된 공간에 생성이 불가능하다면 실패
    불 전파: 8 타일 중 조건을 만족하는 타일로 번저 나간다
    지하에 지지되지 않은 곳은 위험하다
    1s: 아이템은 10 개 초과 겹치면 5 데미지를 입도록 하자

## map generation
    256 * 256 크기로 한다
    처음 시작하는 중앙에는 돌 타일을 깔아주자
### ground
    중앙에서 20 타일 떨어진 곳에서 섬 바깥쪽으로 강이 한 줄기 흐른다
        강의 중심은 깊은 물이고 땅 사이에 얕은 물을 한 칸 갖는다
        강의 중간부터 깊은 물은 바다와 닿는 곳에서는 3 칸으로 늘어난다
        얕은 물은 물 원천에서는 좌우 1 타일부터 시작해 점점 넓어져서 나중에는 좌우 4 타일까지 넓어진다
        강의 꺾임은 10% 랜덤성을 준다
    각 나무 군락이 하나씩 존재한다
    꽃, 풀이 무성하다
    가장 바깥쪽은 5 ~ 6 타일 정도가 deep water 이다(맵 밖이 안보일 정도로 + 2)
### underground
    10% 는 구리이다
    5% 는 철이다
    구리 광맥이 존재한다
    철 광맥이 존재한다
    중앙에서 20 타일 떨어진 곳에서 맵 바깥쪽으로 동굴이 한 줄기 존재한다
    동굴의 폭은 1 ~ 5 로 서서히 랜덤하게 변한다
    가장 바깥쪽은 5 ~ 6 타일 정도가 bedrock 이다

## UI
### portal scene
    discord link
### mode: 메뉴 버튼 밑에 있는 버튼이다
    interaction mode
    observation mode
### sense message
    시각, 후각, 청각, 촉각, 미각에 대한 정보를 출력한다
    검게 흩뿌려진 배경에 흰 글씨를 사용하여 감각적인 정보임을 강조한다
    있는 그대로 느껴지는 정보를 출력한다
### log
    - 내구도가 다하여 부서진 경우
    - 마스터리 레벨이 오름
    - 상호 작용의 결과
        good -> 좋은, common -> "", poor -> 나쁜
    화면 최상단에 작게 로그메세지를 띄운다
    레벨업 관련: 레벨업 시 캐릭터 주변에 작은 파티클을 날린다. 이 때 파티클 만으로는 어떤 기술이 레벨업 했는지 알 수 없기 때문에 로그 메세지를 띄운다
    로그를 클릭하면 로그 페인을 보여준다
### info pane
    - common object information
        - simple description
        - usage: 나무가 나무 스틱을 얼마나 가지고 있는지, object interaction, object mechanism
    - personal object information
        - quality
        - durability
    이 화면의 아이콘을 터치하면 해당 아이콘의 설명을 띄운다. 뒤로 가기는 없다
### mastery: 캐릭터를 롱터치하면 띄운다
//      skill: 다양한 스킬에 대한 마스터리. 다양한 방식으로 영향을 준다
//          mobility:
//          power: 최대 들 수 있는 무게
    craft: 각각의 모든 제작 품에 대한 마스터리. 품질에 영향을 준다
    interaction
        object
        terrain
### option
    show quality check box
        field object
        building object

## game object
    - 정의해야 할 것: 조합법(워크 스테이션), 상호작용
    - 오브젝트 오른쪽 위에 퀄리티를 표시하며 오른쪽 정렬을 한다 가로는 5칸 넓이
    - object 와 tile 은 다르지만 tile 은 object 가 가지는 속성들을 다 가져야 한다
    class property
        - isMovable
        - isWalkable
        - isBurnable
    instance property
        - state { normal, burning, planted }
            상호작용하여 상태를 정상으로 만들 수 있다
        - createdTime
        - isArtifact: 한 번 퀄리티 영향을 받은 오브젝트는 다시 영향 받지 않는다
        - havingGameObjectCount
    pottery
        - 반죽을 dough 라고 할까?
        - wet 은 12h 이 지나면 dry 상태가 된다
        - wet 을 태우면 cracked 상태가 된다
        - 불 데미지를 받지 않는다
        - dry 는 1h 태우면 완성품이 된다
        - cracked 는 내구도가 1 이다
        - wet 은 내구도가 2
        - dry 는 내구도가 3
    baked goods
        - 불 데미지를 받지 않는다
        - dough 를 1h 태우면 완성품이 된다
    building
        - 파괴 시 재료의 절반을 드롭한다
    tool
        - grade: stone, copper, iron
        - 제작: 재료 2 개 + wood stick, iron 은 anvil 요구
        - 내구도 차이만 두자. 돌은 1 배, 구리는 2 배, 철은 3 배
        - 내구도는 기본 10
        - good 은 내구도가 닳지 않는다. common 은 1 닳는다 poor 는 2 닳는다
        saw: make board
        sickle: cut weed or crop
        shovel: dig
        axe: chop wood
        pickaxe: mine
        scissors: cut leaf
        hammer: destroy
        hoe: cultivate dirt
    terrain
        water
            - 깊은 물이나 깊은 물과 15 타일 이하로 떨어진 얕은 물에 오브젝트를 떨어트리면 사라진다
            shallow water: 물을 푸면 내구도가 1/16 감소한다, 흙을 넣으면 흙 땅이 된다, 깊은 물과 인접한 얕은 물은 흙이 채워넣어 지지 않는다, sand 를 4 개 까지 지닐 수 있다, 삽으로 sand 를 얻을 수 있다, 깊은 물과 연결되어 있지않은 경우 하루에 1/16 씩 내구도가 감소한다. 깊은 물과 1 타일 멀어질 때마다 물 보장성이 1/16 씩 감소한다
            deep water: 물을 퍼도 사라지지 않는다, 아이템을 버릴 수 있다. 깊은 물과 땅 사이에는 반드시 얕은 물이 있어야 한다
        grass: 삽으로 상호작용하면 grass 를 얻으며 dirt 가 된다. grass 는 퍼지긴 하지만 땅을 높이지는 않는다
        dirt: 삽으로 상호작용하면 soil 을 얻으며 dug dirt 가 된다
        dug dirt: 삽으로 상호작용하면 stone ceil 이 된다. 생성된지 2 주일이 지났고 인접한 흙 타일이 있다면 다시 흙이 채워진다
        stone ceil: 곡괭이로 상호작용하면 stone 을 얻으며 hole 이 된다. underground layer 의 같은 위치 tile 이 cave floor 가 된다
        hole: 지하로 내려갈 수 있다. 물을 흡수한다. 홀에 돌을 채워 넣으면 돌 천장이 된다, 해당하는 지하 타일은 돌 타일이 된다
        underground floor: 뚫린 지하의 기본 타일, 이벤트로 돌 템플릿이 생성될 수 있다
        underground entrance: 지상에서 지하 입구를 파면 같은 위치의 지하 레이어에 이 타일이 생성된다. 이 타일은 계단처럼 생겼으며 non-walkable 이다
        soil wall: 지상의 지하 입구가 막히면 지하에 생성된다. 지하에서 이 벽을 팔 경우 지상에 hole 이 다시 열린다
        cave floor: cave 의 바닥, 돌 템플릿이 생성되지 않는다
        wood floor: wood board 2
        stone floor: stone 2
        minable tile: good 이 뜨면 벽이 부서지면서 돌이나 광물을 드랍한다
            stone tile: stone 이상의 곡괭이로 캐면 stone 을 얻는다
            copper tile: stone 이상의 곡괭이로 캐면 copper ore 를 얻는다
            iron tile: copper 이상의 곡괭이로 캐면 iron ore 를 얻는다
    bridge: 얕은 물이나 땅에 붙어있는 깊은 물에 지을 수 있다. 내구도는 벽과 같다
        wood bridge: wood board 4, 땅에서 1 칸 만큼을 지탱한다
        stone bridge: stone 4, 땅에서 2 칸 만큼을 지탱한다
        brick bridge: brick 4, 땅에서 3 칸 만큼을 지탱한다
    wall
        clay wall: clay 1, 내구도 5
        wood wall: wood block 4
        wood door: wood board 3
        stone wall: stone 4, 내구도 20
        brick wall: brick 4, 내구도 30
        copper wall: copper 4, 내구도 30
        iron wall: iron 4, 내구도 40
        bedrock: 지하의 최외곽 벽
        glass wall: glass 4, 식물이 뿌리를 내리지 못한다
    resource
        soil
        sand
        glass: sand 를 태운다 3h
        clay
        brick: clay 1
        stone
        grass
        copper ore
        copper
        iron ore
        iron
    crop
        barley: wait barley seedling 1w, 성장 시 퀄리티는 땅에 영향을 받으며 땅의 내구도를 1 감소시킨다, 스프라이트가 캐릭터 윗쪽에도 있다, 낫으로 수확 시 barley seeds 를 2 개 준다
//      수박
//      딸기
//      당근
//      감자
    crop related
        barley seeds: barley 를 낫으로 수확하여 얻는다
        barley seedling: barley seeds 를 경작된 땅에 상호작용한다
        barley flour: quern + barley seeds 2
        barley bread dough: barley flour 2 + water 1
        barley bread: burn barley bread dough, 상호작용하면 보유한 랜덤한 mastery 경험치가 10 오른다, 퀄리티 배율을 먹는다
    working station
        - 일부 오브젝트는 제작 시 작업대를 요구한다(벽, 가구 등)
        workbench: wood board 4 + wood block 2
        quern: workbench + stone 2
        anvil: iron 8
    furniture
        chair: workbench + wood board 1 + wood block 2
        table: workbench + wood board 2 + wood block 2, 아이템 진열 가능
        thatch bed: workbench + leaves 10
        book: workbench + weed 10
            책에 오브젝트를 상호작용하면 그 오브젝트에 대한 책이 된다
            한 번 오브젝트가 설정 된 책은 다른 오브젝트로 바꿀 수 없다
            오브젝트가 설정된 책을 캐릭터 인벤토리에 넣어두면 그 오브젝트를 획득하는 mastery 가 최대 10 레벨까지 1 초에 1 씩 경험치가 오른다
                단, 해당 마스터리 레벨이 최소 1 이상이어야 한다
                만약 해당 오브젝트를 생성하는 mastery 가 여러개라면 매 효과마다 10 미만인 mastery 하나를 랜덤하게 선택하여 1 올려준다
            책은 반드시 로그인 상태여야 효과를 발휘한다
            액체가 담겨 있는 액체 컨테이너로 상호작용하면 해당 액체에 대한 책이 된다
        unburned wet clay pot: clay 2
        unburned dry clay pot: unburned wet clay pot + 24h
    game object container
        - 아이템 획득 시 인벤토리에 공간 및 가방이 있으면 바로 들어옴
        - 필드에 있는 컨테이너는 상호작용하면 캐릭터 위쪽으로 컨테이너의 인벤토리가 열린다
        - 캐릭터 인벤토리에 있는 컨테이너는 상호작용하면 캐릭터 아랫쪽으로 인벤토리가 열린다
        - 컨테이너 이외의 오브젝트를 보관할 수 있다
        - 한 컨테이너를 드래그 해서 다른 컨테이너에 오브젝트를 전부 이동시킬 수 있다
//          - 만약 들고 있는 컨테이너가 비어 있거나 대상 컨테이너가 가득 차 있다면 반대로 아이템을 전부 가져온다
        - 대량 이동은 높은 퀄리티를 우선적으로 옮긴다
        leaf bag:  leaves 2, 2칸
        vine basket: vine 2, 3 칸
        wood box: workbench + wooden board 2, 4 칸
        copper box: workbench + copper 2, 5 칸
        iron box: workbench + iron 2, 6 칸
    liquid container
        - 물을 풀 수 있다
        - 내구도는 기본 10
        clay pot: burn unburned clay pot, 2 unit 의 물을 풀 수 있다
        wood bucket: wood board 2, 4 unit 의 물을 풀 수 있다
        barrel: workbench + wood board 2 + iron 2, 16 unit 의 물을 풀 수 있다
    tree
        - inventory object count: 4
        - 나무를 도끼로 베면 씨앗 2 개와 tree log 가 나온다
        - dug dirt 에 씨앗을 두고 soil 을 두면 나무 싹이 난다
        - 상호작용하면 tree 가 가지고 있는 object 를 전부 얻는다
        oak tree
        apple tree
//          maple
//          zelkova
//          ginkgo biloba
    wood
        leaves: scissors 로 나무를 상호작용하여 무한히 얻을 수 있다. 나뭇잎 하나 말고 몇 개 있는 걸로 그리자
        wood stick: burn 1h
        oak acorn
        apple
        tree log: axe 로 상호작용하면 wood block 을 생성하며 내구도가 1 닳는다. saw 로 상호작용하면 wood board 를 생성하며 내구도가 2 닳는다
        wood block: burn 5h
        wood board: burn 10h
    plant
        vine plant: 상호작용하면 파괴한다, 가위로 상호작용하면 vine 을 얻을 수 있다
        short weed: 상호작용하면 파괴하며 희박한 1% 확률로 crop 을 드랍, 1 주일이 지나면 키 큰 풀이 된다
        tall weed: 가위로 상호작용 시 weed 를 얻는다. 이외의 방식으로 상호작용하여 파괴 시 2% 확률로 crop 을 드랍. 스프라이트가 캐릭터 위쪽에도 있다
        flower: 꽃을 번식시키면 두 꽃의 중간 색이 나온다. rgb는 2byte 로 저장하며, 결과를 균등하게 분배하기 위해 짝수 쪽으로 반올림한다
    곰: 필수다. 평화로운 곰 한마리를 배치한다. 자유롭게 섬을 돌아다닌다
    pillar
        - 택시 거리 n 에서 오브젝트가 피해를 받고 돌이 생성되는 것을 막는다
        - 벽과 같은 내구도를 갖는다
        - 지지 타일 이외의 타일을 채광했다면 rare 가 아닌 이상 낙석이 떨어진다. 낙석은 + 모양으로 돌을 형성하며 지지 타일에 떨어질 경우 해당 영역을 커버하는 기둥에 피해를 입힌다
        wood pillar: 2, wood board 3 + wood block 1
        copper pillar: 3, copper 3
        iron pillar: 4, iron 3

## sound for animation
    system
        button touch
        craft sound
    interaction
        tree chop
        walk
        walk on weed
        walk on water
        something destroyed
        water drop(퐁당)
    ambient
        bird sing
        water flow
        tree rustle
        firing

# issue
-
mastery system
    apply mastery system

particle
    rare gold
    common silver
    poor bronze
    fail grey
    level up red

character long touch
    display mastery level info

bug
    i can't touch reset no button
    if i interact water with container, the contents will be dagling
        remove only the items inside the container

underground

display expected quality to craft object

fire
potery

shallow water

container
    another image for empty, normal, full

add
    sickle
    saw
    board
    block
    wood box
dirt to clay tile will make dirt tile removing dirt
add oak tree sapling
double click -> interaction or consume
    field GO also can be activated
implement underground
remove GO when put to water
draw
    log, leaves
create tree
inventory in characterInv
    add leaf bag
만약 한 청크를 건너 뛸 정도로 빠르게 이동하면 터지지 않을까?
    한 청크 이상을 건너는 속도는 불가능하도록 제한한다
지상 및 지하를 미리 로딩해둔다
타일간 상호작용 구현
menu button -> cancel all gesture
캐릭터 이미지 추가하기
    옆에서 보는 이미지가 좋겠다
world generator
    generate in chunk unit dynamically
    sea

mastery
brick
fire
info

optimize accessibleGOTracker::update()

example code
func isDeepWater(seed: Int, chunkCoord: ChunkCoordinate) -> Bool {
    return true
    return chunkCoord.chunk.address % 2
}

월드의 좌우, 위아래가 각각 연결되어 있다
그럼 이걸 구형이라고 한다면
위도 0은 어디이며 위도 90은 어디일까?
적도는 어디이며 극은 어디일까?
가운데를 적도라고 하자,
그럼 극은 2 곳이어야 하므로 1/4 과 3/4 이 극이어야 한다
그럼 위와 아래는 또 다른 적도가 되어야 한다
그런데 문제는, 적도를 돌아서 다른 적도와 만날 수 없다는 것이다
그럼 결국 적도는 하나만 배치해야 한다
그럼 구형 월드가 아니라 원통형 월드라면 어떨까?
좌우는 연결되되, 상하는 끊어져 있다
그래서 중심에 1 개의 적도와 상하에 2개의 극을 가질 수 있다
그럼 적도는 0 이고, 멀어질수록 높이가 1 청크당 1 씩 높아진다고 하자
그럼 적도에 물이 모이고 양 극은 대륙이 될 것이다
하지만 물은 땅과 같은 면적이라고 한다면 평균 높이를 해수면으로 잡으면 안된다
물은 삼각뿔 형태에 모이기 때문에 땅의 평균 높이보다 더 높아야 물의 양과 땅의 양이 같게 된다
하지만 그렇게되면 땅이 다 사라진다
즉, 물과 땅의 비율에서, 물이 더 적어야 한다
물의 양을 적절하 조절하자
지구와 같게 하는게 좋겠다
표면의 물 비율은 70 퍼센트로 한다
그럼 전체 높이는 청크의 "y 좌표" + "chunk.coord.y" 이니 이 값의 70% 를 해수면으로 한다
여기에 변주를 줘야 한다
강은 당연히 있어야 하는 것이고
    화산 폭발
    대륙 이동
    혜성 충돌
한 청크를 시뮬레이션하기 위해서는 최소 그 주변 청크까지 시뮬레이션 해야 하지 않을까?
해안선을 랜덤하게 절반씩 결정하는게 좋다
[] 한 128개의 높이를 설정해야 한다고 하면
0번 높이는 0이라 하고
64번 높이는 n의 랜덤성을 주고
32번 높이에 평균에 n /2 의 랜덤성을 주고
반복, 너무 단조롭지 않을까?
괜찮을 것 같긴 하다
하지만 이 알고리즘은 특정 지점을 알기 위해 다른 지점의 계산을 요구한다
반대로 작은 랜덤성으로 큰 랜덤성을 유추해나가는 방식이 있으면 좋겠다

region 마다 방향을 하나씩 가지게 한다
    region 은 큰 영향을 미친다
chunk 마다 방향을 하나씩 갖는다
    chunk 는 작은 영향을 미친다
고정된 multiplier 와 increment 를 준비한다
seed 에 따라 chunk 를 계산하여 그린다

game object must have it's size not default node size
    terrain -> default node size
    else -> middle size
캐릭터는 월드에 귀속된다
add mastery system

interact 구현
    씨앗 -> 나무
    나무 맨손 -> 나뭇가지 or 씨앗
sound 구현 및 추가
    background
    interact
    button touch
fix friction
touch pine cone make pine tree
Add interaction
    wood wall with axe
    pine cone
    pine tree with axe
add tools
add quality
hide reset button to menu window
이력서 정리해서 보내드리기

## low priority
sand color is to yellow
dirt has wrong outline
add fade effect
add sound
long info touch
    add timer
address -> addr
벽 뚫는거 막는게 좋다
add small none texture
redraw game object
    wood is to dark
    grass is to green
    bright is better than dark
    잔디 좀 더 연두색으로
불필요한 경우 1 fps
GameObject.instance == GameObject.instance 가 되던데 어떻게 되는거지?
세상의 끝을 설정하긴 해야 한다
<< 도 exception 이 발생할까?
make texture manager
    Texture.button -> rawValue(?) has SKTexture
아종 데이터
알림 센터를 내리고 있는 상태에서 필드 드래그 터치가 작동하는 현상
인벤토리와 제작은 아예 화면 테두리에 붙여도 될 것 같다. 피아노 건반처럼. 특히 제작은 그렇게 할 것. 그래야 스크롤이 편해진다
    마찬가지로 잔디가 퍼져야 하는지도 리스트로 관리한다
sense message 켜고 끄는 기능을 menu 에 넣는다
sense message
search testflight
button custom image

# test
pan recognize distance
pinch recognize delta
pan and pinch whether apply bPosition
multi touch on physical device

# mandatory: 기대 시간(h) + 요구 사항
view
    game scene
        tileLayer
        gameObjectLayer
        uiLayer
            인벤토리(하단)
            메뉴(정지) 버튼(우측 상단)
            제작 버튼(롤코타처럼 버튼 누르면 서브 아이템 버튼 show) 제작 버튼은 흔하게 왼쪽에 세로로 두자

auto save
    6 구체화 및 구현
    일정 시간마다 자동 저장(변경이 발생할 때마다)

UI
    1 구체화하기
    layer: 바닥 > 벽 > 오브젝트
    바닥 타일은 모눈 회색 테두리를 가장 윗 레이어에 둬서 타일이 구분되도록 하자
    상호 작용 시 뽁 소리(입으로 녹음)

타일
    100 * 100 칸으로 일단 만들어보자
        상수 파일 분리(MAP_WIDTH_TILE_COUNT, MAP_HEIGHT_TILE_COUNT)

캐릭터
    이미지: 기본 이미지 + 모자 + 손 장비
    5 스킬
        도끼 제작 스킬
        나무 스킬
        밸런스
            살짝 불합리할 정도로 느리게, 종결은 좀 대단하다 싶을 정도로 과하게
    캐릭터가 위치한 타일과 인접한 8 타일을 터치하면 interaction 가능
        ex) 나무하기, 줍기
        상호작용 애니메이션
            도끼질: 손 기준 45 도 왕복 회전 일단 같은 속도 1 초 주기로

인벤토리
    인벤토리 크기는 5 칸

장비
    모자
    왼 손
    오른 손

아이템
    아이템은 합쳐지며 최대 99 개 제한(갯수는 아이템 이미지 우측 하단에 표시)
    아이템을 드래그하여 들 수 있다
    들고 있는 아이템을 내려 놓을 수 있다
        장비 칸
        인벤토리 다른 칸
        인접 타일 위
            캐릭터가 있는 타일
                만약 이미 아이템이 있다면?
                아이템이 버려지지 않고 드래깅 상태인 것으로 묘사한다
                    작은 원을 그리는 애니메이션
        내려 놓는 위치에 합칠 수 있으면 아이템을 뭉탱이로 합친다

GameObject
    Pickable: stone
        pick, interact, durability
    Interactable: tree
        interact
    Destroyable: building
        isWalkable = false, durability

4 sense message
    interaction 시 조건이 맞지 않을 때 무엇이 부족한지 출력(가장 위 레이어)
    fadein 1, 1.5, fadeout 0.5

컨트롤
    7 move: pan 하여 이동 적용(갈 수 있고 없고)
    7 interaction: 근처 타일 터치
    멀티 터치 가능
        한 손으로 팬하여 이동하면서
        다른 한 손으로 아이템을 들고 옮긴다
        touchMoved() 의 인자로 들어온 UITouch 인스턴스가 캐릭터 움직임에 사용되고 있는 터치인지 식별이 가능할까?

컨텐츠(이미지, 사운드) 생성 및 적용하기
    오브젝트의 타일 이미지와 인벤토리 이미지는 같은 것을 사용한다
    1 타일 배경
    1 배경 음악
    1 나무
    1 나무 씨앗
        심으면 현실 시간 몇 시간 후에 성장한다
    1 나무벽
    1 돌: 기본적으로 바닥에 떨어져 있다
    1 나뭇가지: 맨 손으로 나무와 상호작용하면 주변 빈 타일에 생성된다
    1 도끼: 나무와 상호작용하여 log 를 얻는다
    1 망치: 건물을 부순다

건설
    건설할 오브젝트를 드래그하여 캐릭터 주변에 드래그하면 회색으로 건설될 예정 모습을 보여준다
    드래그를 때면 건설이 되며 재료가 차감된다
    캐릭터가 건설 부지 위를 차지하고 있다면 예정 모습에 붉은 마스크를 해주자

# finish
fix craft system not working
chunk data logic::move()
chunk data::synchronizeData()
inventory logic::move() -> inventory data logic::move()
quality
    apply LogicContainer.default.go.new()
    apply go.set(type)
    apply LogicContainer.default.scene.new()
space of inv must stored property
inv to inv transfer
bug
    when transfer from close container -> the source container don't redraw
    when transfer to close container -> empty coord always first cell
    not interact? when from cell to container
vine basket
    vine
3 앱 아이콘 만들고 적용하기
5 광고 추가하기
    화면 상단 일부
    깃에 올릴 것이므로 id 정보는 뺀 상태로 완성하기
스플래쉬 뷰?
    2 안드로이드에서 스플래쉬 뷰라고 불리는 초기 로딩 화면 설정하기
scene logic::chunk update()
    update chunk container
    hide open field inventory if need
clay interact to cave ceil -> clay tile
sand interact to clay tile -> sand tile
dirt interact to clay tile -> dirt tile
if field touched and has GO, interact
if cell touched and has GO, interact
if the id of inventory is not 0, inventory GO should not put
change field touch
bug
    put GO to invInv and move invGO to field, than reopen -> difference window
    when i put invInv.2 -> it first put charInv.2
    move game object inventory cells proper point
    item is not entered proper coordinate
    close inventory when the GO is moved another cell or to field
    the field inv is belong to world layer, but it should follow GO
if container is empty, can be put to inventory
invInv must not open
I separated SceneLogic to SceneLowLogic
    apply the difference
restore the removed invContainer, chunkContainer of filed touch logic
make impossible to move GO when the cell is possessed by another GO
    when touch cell which has GO -> relay handle to GO
오브젝트 크기 적절하게 출력하도록 변경
왼손 오른손, 인벤토리 다시 그리기?
WorldScene 에서 menu layer 추가
간단한 아이템 구현
{
    WorldScene 에서 터치에 따른 동작 구현
        터치에 따른 state machine 구상
    isWalkable 에 따른 캐릭터 이동 구현

    pan -> 이동 (1 개 제한)
    flick -> 미끄러지는 이동
    item pan -> 아이템 이동 (1 개 제한)
    button touch -> 기능 수행
    item touch -> interact(multi touch -> add queue)
}
아이템을 드래그해서 내려놓는 기능
    placeholder 를 보여주고 불가능하면 못내려 놓는다
데이터 관리
    캐릭터
        위치, 스킬
    바닥 아이템
    오브젝트
sense message 구현


enterButton, resetButton 맞춤 resource 제작
제작 구현
item drag 구현
portrait and upsidedown

터치 간의 상관 관계
    메뉴 버튼 터치 -> 드래그 중단
swap with inventory go
when pick up item from inventory or field, reserve craft pane update

fix flick to persist direction

menu window touch
menu -> cancel all touch
save character position
PortalScene touch
check CraftPane
    consume
    update
check game object touch
if craft object type changed while touching, cancel the touch
캐릭터를 조금 아래로 내려서 위 영역을 터치로 사용하는 대신에 상호작용 가능한 영역을 2 거리까지 띄운다
터치, 드래그 -> 기본 이동
꾹 누르고 있기 -> 설명
제작
    아이템을 겹치면 제작 더미가 생긴다
    아이템을 충분히 넣고 제작 더미를 상호작용하면 성공하면 아이템을, 실패하면 제료를 반환한다
캐릭터를 조금 아래로 낮춘다
make cancel touch when craft reset
make reset pane and menu pane as button
터치 시작 시 살짝 튕기는 글리치
타일 크기가 딱 맞아서 검은 실선이 보이는 오류
처음에만 zone 을 만드는 합수가 있고 그 다음은 전부 reserve 로 작동한다
    addZone, removeZone 에서 should reserve 를 true 로 바꾼다
    매 update() 에서는 should update 가 true 인 경우에만 돌린다
craft cell 이 제작에 소모될 아이템 리스트를 갖도록 하자
button 은 무조건 부모가 처리하도록 해보자
resolve portrait warning
캐릭터의 테두리 색을 검은색으로?
인벤토리 셀을 클릭하면 셀의 알파를 변하게 하자
update model
craft 는 이벤트로 보내고 controller.update() 에서 처리하기
crash when exit, by EventManager.default! at WorldScene.touchbegan()
implement inventory
make temporary circle at touch location
take item invInv also
implement craft system
add FrameCycleUpdateManager.default.update(with: .craftWindow)
but in case craft window, updating at update() in the scene is good choice
    udpating every add and remove of game object will lower performence
game object is added to accessible tracker
    mimic that behabior for craft window
no need update accessibleGOTracker
    udpate only beginning
change chunk view to just world
debug 에서는 터치 포인트에 원이 따라다니게 하기(hide, reveal)
service container 를 만드는건 portal view controller 가,
    전달받아서 등록하는건 world view controller 가
git 받아서 실행해보기
인벤토리 위치를 생각해보자
밑에 있어도 되는데 옆에 있다면?
    아니 그냥 밑에 둘까?
캐릭터 주변 1 칸만 상호작용 가능한거는 구리다
줌 인 줌 아웃
잔디 퍼지는거 시간은 상관 없다
게임 자체적인 재미가 있어야 한다

prevent control center is activated at touch(other games prevent it)
change accessibleGOTracker only track non walkable

craft
    possible must have empty inventory space
    remove event activatedGO, and remove from activated at Global

adding and removing GO must in the GOHandler not event!

craft touch handler

무료 에셋 찾아보기
조금 빨라지기
ui 드래그로 아이템 옮기는 기능 삭제
    터치 터치로 상호작용 시키기

pan recognizing: remove time, change velocity -> position from origin
인벤토리 셀 터치하면 아이템 이동
필드 터치하면 아이템 이동

지금 WorldScene 에서 터치를 다 받아와서 recognize 하도록 하고 있는데 굳이 그래야 할까?
일단 recognizing 을 위해 모든 터치는 recognizer manager 로 보내고
후에 적절한 handler 를 호출하는 방식

이 문제 해결
    view 하고 scene 하고 locatino 다를텐데..
    시간을 초기 설정하는 방법
atPoint(point) 를 사용하면 기존의 go.touched() 를 재현할 수 있다
portalScene touch 확인
GameObject::fieldPosition
new touch
    if not pickable, interact
    else touch inventory GO -> activate GO
        touch another GO -> GO interact
        else touch empty cell -> put
        else touch empty or tile field tile -> put
    else touch field GO -> take to inventory

drag -> move
거리 제한 해제

apply walkable
apply interact to tile

character update
if character moved
    if character moved to another tile
        character save position
        if character moved to another chunk
            chunk container update
    moving layer move with character position
character 안에 chunkCoord 를 넣는다
    없으니 너무 불편하다
    그리고 chunkContainer 의 midCoord 를 없애고 매 번 입력받는 방식으로 변경한다

업데이트 리스트를 둘까?
업데이트 리스트를 둔다고 하더라도 매 번 리스트 입출력 이벤트를 호출해야 한다
매번 드나들 때마다 액티브를 변경하는 것이 아니라 마지막에 몰아서 하는게 맞다
근대 옮기고 있는 오브젝트는 어떻게 제외하지?
캐릭터 위로 옮겨두는게 가장 무난하다
그리고 필요하면 다시 원래 chunk 로 돌려놓는다

check go whether accessable or not when move ended came back
game object'id can be 0 at generation

rename WorldUpdateManager

coordinate
    streetCoord
    buildingCoord
location
address
    streetChunkAddress
    streetAddress chunkCoord.street.address
    buildingAddress chunkCoord.street.building.address

-
coord -> x, y
address -> UInt

chunkCoord.x
chunkCoord.y
chunkCoord.chunk

chunkCoord.chunk.address
chunkCoord.chunk.coord

chunkCoord.chunk.street.address
chunkCoord.chunk.street.coord

chunkCoord.chunk.building.address
chunkCoord.chunk.building.coord

streetChunkAddress ->
StreetAddress -> ChunkAddress

move character position update to new handler file

make each inventory as computed property

move character display 1/3

move character move touch to moving layer
    or world layer

fix GO drag bug
InventoryProtocol::coord(touch: UITouch) { }
if only the original coord is accessible, rewind
if inventory is not accessible fail
if no go interact to go, check

when tile move, improve the performence of accessibleGOTracker
데이터를 분산적으로 갖지 않는다
    캐릭터의 위치를 여러 객체가 갖지 않는다

touch event handler
    CharacterMoveTouchEventHandler
    GameObjectTouchEventHandler
    GameObjectMoveTouchEventHandler
    CraftObjectTouchEventHandler
    CraftObjectMoveTouchEventHandler

interac zone 을 deprecated 로 옮겼는데, 아주 삭제는 아니고, 개념은 있어야 하나? 생각해보기
ChunkContainer 처럼 InventoryContainer 도 있어야겠다
    그래야 update(), remove() 하고 그 안에서 go.set 하지

remove interaction zone
    그럼 zone 이 하던 일은 어디에 넣어야 하나?
    update accessable gos
    field?
    field 가 accessable 을 따로 관리하도록 하자
    이게 맞나? 일단 그렇게 해보지 뭐

add inventory
remove view model
add child 는 기본적인 경우
move 는 position 을 유지하고 싶은 경우
unite event queues

ChunkContainer::update() 에서 go.removeFromParent() 를 부모가 없는 node 에 하면 어떻게 될까?
    (새로운 노드를 추가하는 경우)
    아무 일도 없다
model 을 인자로 다른 controller 에게 전달하도록 하기
controller 에 따라 파일 hierarchy 수정
캐릭터 노드를 field 위로 이동
필요에 따라 상하좌우에 서로를 가리키는 구조 사용
MO 를 가져오면 기존에 MO 랑 동일한 객체일까?
도트 찍는 프로그램 알아보기
타일맵 더 알아보기
init() 알아보자
구역을 나눠서 go 를 보관하고, 필요한 go 만 메모리로 관리하면 되겠다
view controller 로 두 scene 을 분리해야 할지 조사하기
세 번째 손 없애기
repository 조사
a bug that can't move from touch of out of world bound
fix moving game object to out of world border
PortalScene 에 reset window 추가
도끼 구현
WorldScene 에 exit button touch 구현
손 이미지 추가
타일도 캐릭터의 위치 데이터와 마찬가지로 앱을 종료, 중단 시에 저장해도 충분할지 조사
컨텐츠 추가
    나무
    도끼
    나무 바닥
    나무 벽
    망치
    돌맹이
flow
    touch
data(memory, disk)
    TileMap, GameItem
structure
    MVC, class reference
```
├│─└


ViewController
├─ PortalSceneController
├─ WorldSceneController
```
character radius 이상의 거리를 1 프레임에 움직이면 벽을 뚫을 수 있다
캐릭터 포지션을 chunkEventHandler 에서 update 하는 로직 refactor
position 에서 moving layer 의 위치를 바꾸지 않도록 하자
_position 을 두고 이를 get set 하도록 한다(super 의 position 을 피하기 위해서
    근대 아무리 그래도 이름이 position 이면 node 를 그리기 위한 데이터로 사용할 것 같다
    그럼 어차피 psition 은 항상 0 이어야 하겠네?
    아하, character 를 movingLayer 위에 올리면 된다
    그러면 position 이 의미있는 값을 가져도 화면에 올바른 위치에 출력된다
    그런가? 한번 position 으로 실행해보자
chunk 로딩 문제 해결
    chunk 의 로딩 자체는 잘 되는 것 같다
    chunk conotainer 가 잘못된 좌표의 chunk 를 로딩하고 있는 것 같다
character 의 위치가 이상하게 저장되는 문제
chunk 가 이상하게 삭제되고 로드되는 문제
character move manager 를 character node 와 character move touch responder 로 분리하고 있다
add child chunk
what about create file at Worldgenerator?
캐릭터의 위치도 CGPoint 는 계속 청크가 움직일 때마다 초기화시켜야겠는데?
    애초에 위치 데이터를 ChunkCoord 를 기반해야겠다
Implement ChunkViewModel
movingLayer.setPosition(by: characterPosition)
dragMove.hasChunkMoved -> chunk moded event
이럴꺼면 오픈월드로 하지..?
tile 도 테이블에 넣고 chunk 단위로 로드하기
chunk 가 변할 때 새로운 chunk 로드하기
tile view 를 chunk 단위로 만들기
    사실상 tile 을 game object 로 처리할 것이기 때문에 9 개만 있으면 된다
touch drag 도 이벤트로 보내고 controller.update() 에서 처리하기
    아닌가, 터치는 자신이 처리하고 추가적인 처리가 필요한 경우 보내야지
main branch 는 stable 만 merge 하자
    ff 를 하니 stable 을 알 수가 없다
LMIEventManager
    LMIEvent
WorldViewModel
    Field
    Field Inventory
    Character Inventory
    Character Inventory Inventory
    Character
밖에서 그냥 넣어주던거 가능하면 함수를 통해서 넣어주자
modify & to < in fetch predicate format
recompose zposition
타일을 sql 로 저장하기...
world view model 은 service 에 직접 접근하지 않아야 한다

## after view layer
world scene
    world layer
        moving layer: process drag move
            (tile map)
                (floor map) * 9: 어떤 녀석이 어디에 있는 녀석인지 계속 알아야겠네?
            field: field inventory
                (game objects)
        character
    (fixed layer)
        (ui)
            (menu button)
            inventory pane: character inventory
            craft pane
        menu pane

rename container to inventory
remove third hand
clean view controller init(), viewDidLoad(), setUp()
동적 로딩 구현하기
load gomo for need
    필요한 만큼만 저장하고 동적으로 관리하기
    16*16 을 한 청크
    내가 있는 청크를 기준으로 총 9 청크만 로드해두기
    캐릭터 위치도 중요하겠는데?
    타일도 코어데이터로 관리해야 하려나? 이건 나중에
    캐릭터 위치에 따른 청크가 바뀌었는지 함수
    캐릭터 위치에 따른 타일이 바뀌었는지 함수
    근대 청크로 하면 캐릭터의 위치를 xyz로 하는게 좌표 체계가 일치하지 않아서 불편하지 않을까?
    아하 데이터 관리는 청크 기반으로 하고, 메모리 데이터 상으로는 xy 좌표 체계로 정리하는거지
    하긴 그러면 디스크로부터 새로운 데이터를 가져오는 경우 fetch 에 시간이 감소하는 대신 쓸 수 있는 상태로 변형하는데 연산이 조금 더 필요
    이를 go model 에 적용하기
    0,0 을 시작 지점으로 하자
    그럼 -256 ~ 255 사이즈로 만들어 보자
    로딩은 캐릭터 위치 계속 추적하면서
    캐릭터를 모델과 뷰로 구분한다면
    캐릭터가 타일을 바꿀 때마다 뷰컨트롤러에게 캐릭터 위치 변경을 요청하기
    캐릭터 위치가 바뀔 때마다 청크가 움직였는지 판단하기
    움직인 경우 필요한 청크 데이터 로드하기
    그럼 청크 단위로 데이터 로드하는 함수가 필요하다
    왜 같 id 가 여러 번 출력되지?
캐릭터가 0,0 에서 시작한다고 하면 각 사분면? 으로 청크를 하나씩 두기
    청크의 크기는 256 * 256 이니 총 맵의 크기는 512 * 512 가 된다
    타일도 청크 단위로 동적 로딩하자
    만약 데이터가 있으면 그 데이터, 데이터가 없으면 기본은 잔디인걸로
worldSceneModel -< worldViewModel

button 이 따로 deligate 를 설정해줘야 하는 것이 아니라 그냥 부모가 반드시 딜리게이트 클래스인 것으로 호출하기
move character to field
    field 는 터치를 moving layer 에게 넘긴다
캐릭터를 field 위로 옮기고 움직이게 하기
tile 도 generator 로 옮겨오기
game object 가 올바른 위치에 생성되지 않는 문제
새로운 chunk 좌표 시스템 만들기
NextIDService 도 필요할까?
GameObjectRepository::load(chunkLocation: Int16)
chunkLocation 이 일치하는 MO 만 가져오는거 어떯게 하더라?
    let request = NSFetchRequest<GameObjectManagedObject>(entityName: Constant.gameObjectDataEntityName)
    request.predicate = NSPredicate(format: "id == %@", argumentArray: [gameObject.id])
GameObjectRepository 에서 newMO 말고 store 를 사용하는건 어떨까?
make disk controller no singleton
    new it in portal view, and pass it to the world view
    next id 를 월드 별로 따로 두는건 어떨까?
    파일 이름을 보고 dataModelFileName 를 소문자로 바꿔도 될까?
    where worldContainer is init?
    move model from scene to controller
id generator init first id to 2
손 크기 줄이기
버튼 글씨는 버튼 비율로
license 를 알아보자
touch wood wall break but not in inventory
check update flow of zone and pane
굳이 복잡한 이터레이터를 보내야 하나?
    그냥 시그널만 전달하고 나중에 일괄 처리가 단순하다
    context save also same
바닥에 아이템을 주웠을 때 크래프트 페인이 변경되지 않으나, 손에 아이템이 있으면 제작이 실패하기 때문에 섭틀한 부분이 있다
limit multi touch up to two
set app icon
change portal button texture
InventoryNode -> InventoryPane
inventory object is always pickable
remove unneccessary return
field object touch 및 craft touch 중 캐릭터가 이동하여 타일이 바뀌면 경우에 따라서 취소시키기
    craft update 는 가능하면 터치중인 오브젝트를 고정시키기
    만약 없애야 한다면 크래프트 터치를 취소시키기
carry began should reset the status of GO
rename container node
scene 의 touch 도 각 node 들로 옮겨야 한다
ContainerNode 에서 new 를 하다니... 엉망이다
prevent multi game object touch
    make class touch manager
craft add
craft consume
menu window class
menu button class
button class
make character class
move interact to game object
move all touch event out of scene
game object
    activate
    deactivate
move files according to hierarchy
move controller to scene
the go in third hand must have 0.5 alpha
sequenceiterator
if i can consume third hand item, i want to possible to craft
change the direction of craft display bottom to top
셀은 터치하면 필드 터치가 안되고 오브젝트는 터치하면 필드 터치가 되는데 혹시 오브젝트 크기가 0인가? 출력해보자
craft cell touch not work
clean merged world scene
base type to none
set none texture to nil
trace
    WorldScene.updateAccessableGOs()
    WorldScene.updateCraftPane()
    WorldSceneController.addGOs()
    WorldSceneController.addGO()
    WorldSceneController.gameObjectToMO
    WorldScene.add() +1
    GameObjectMO.coordinate
    GameObjectMO.gameObjectCoordinate
setBlendFactor() 를 만들었다
    이제 지운 addAccessableGOs() 를 다시 append 로 교체하고 applyGOsUpdate() 를 호출하도록 수정하자
fix taht some object is below hand texture in inventory
increase accessable area node to cover the center of accessable tile
뭔가 item drag move 가 실패하는 경우가 있다..
container node 만들기
interact
remove unneccessary <Int>
accessable array 는 여기 저기서 호출
    - 타일 변경 등 잦은 호출
    - 월드 시작 시 호출
    - 아이템 생성 시 호출
game object touch -> alpha: 0.5
Container.gameobject add remove
Where to get the position of game object on field?
item is on third hand, move character, put down third hand to tile, pick up the item again, it trigger move touch
check tiletype() and containertype() optional check
remove GameObject
디스크 관리
    일단 데이터는 그대로 간다
    저장, 로드는 곳곳에서 한다
    단, 너무 깊숙하게는 말고, 가능하면 큰 변화가 확실한 곳에서 한다
ManagedObject -> MO
singleton -> lazy
inventoryNode: SKNode
fix not to drop third hand at posessed tile
remove WorldSceneController comment
when flick wall pass bug
isWalkable 구현
border collision
pickable non-pickable

# implementation
enum CompassDirection {
    case east
    case south
    case west
    case north
}

map
    tile[100][100]

tile
    image
    object
    side[4]

struct TileCoord {
    var x: Int
    var y: Int
}

class GameObject {
    var tilePosition: TileCoord?
    var isWalkable: Bool
    var isPickable: Bool
    var durability: Int
}

protocol Interactable {
    mutating interact(GameObject item)
}

protocol Destructible {
    destruct()
}

class Tree: GameObject, Interactable {
}

class Seed: GameObject, Pickable {
}

class Branch: GameObject, Pickable {
}

class Stone: GameObject, Pickable {
}

class Axe: GameObject, Pickable {
}

class Hammer: GameObject, Pickable {
}

# bonus
내 캐릭터를 다른 앱으로 옮기는 기능(애플 아이디와 연동)
CoreGraphic 을 활용하여 상호작용 시 오브젝트의 테두리 색을 초록 혹은 붉은 색으로 바꾸기
tilemap 사용하여 자연스러운 배경 묘사
상호작용 피드백
    사용된 인벤토리의 아이템이 회전
오픈 월드 방식으로 데이터 관리하기
    chunk system
진행 방향으로 더 넓은 지역을 보여줬으면 좋겠다
멀티 가능
성능 향상
토끼
맵 랜덤 혹은 시드 생성
개선 사항
    화면에 적합한 비율의 리소스 사용
여러 월드 생성 가능
아이템이 실수형 위치
    일정 거리 서로 밀어내도록

# dump log

2023-06-18
OOO?    XOOO
OOO? -> XOOO
OOO?    XOOO

678
345
012

 O
 O
 O

 V

 X
 O
 O
(O)

table 에서 이게 쉬운건 1 차원이라서 queue 로 쉽게 구현이 가능하다
2 차원에서는 어떻게 구현할까?
chunk 데이터를 1 차원 배열에 넣고 상황에 따라 삭제, 추가로 위치에 따른 index 를 유지하도록 할까?

CGPoint
    view: 출력 목적
TileCoordinate
    model: 가공 목적
Coordinate<Int>
    온 곳: 누구나 이해하는 공통 규약
ChunkCoordinate
    service: 가공 목적
ChunkCoordinateMO
    repository: 저장 목적

# xcode review
파일을 로드하는데 너무 오래 걸린다
깃을 옮겨다니는 것이 꺼려진다
그 계속 바뀌는거는 자동으로 생성되는거 아닐까?
그거는 gitignore로 안올라가도록 처리해볼까?
그러면 깃 옮겨다니기 꺼려지는 문제가 해결된다
새로운 파일을 만드는 것이 아니라 새로운 클래스를 생성하는 방식도 존재할 것이다!

for {
    function1()
    function2()
}

func function1() {
    publish()
}

func function2() {
    subscribe()
}

2023-06-17
## view layer
world scene
    moving layer
        world layer
            tile map
            field
    fixed layer
        ui
            menu button
            character
            interaction zone
            inventory pane
            third hand
            craft pane
        menu pane

지금은 캐릭터의 위치가 뷰와 상당히 coupling 되어 있다
캐릭터 모델은 데이터만 가지고 있다고 생각하면
위치가 바뀐 경우 컨트롤러가 위치가 바뀌었음을 알리자
컨트롤러는 스스로 캐릭터의 위치를 가지고 있지는 않지만
화면을 드래그하면 무빙 레이어는 계속 움직인다
따라서 간접적으로만 캐릭터의 위치를 트래킹하며
실제 캐릭터의 위치 데이터는 캐릭터 모델이 가지고 있다
하지만 화면 드래깅에 따른 무빙 레이어 이동은 캡슐화하면 좋긴 하다
그래서 전에 이것들을 캐릭터 모델에 넣어둔 것 같다
이 경우 새로운 클래스를 만들면 좋을 것 같다
아니면 움직이는 레이어가 이 일을 맡아도 될 것 같은데?
그럼 캐릭터의 타일이 변한걸 알리는 것은 누가 책임지지?
움직이는 레이어가 책임지나?
아니면 씬이 책임지나?

view controller 의 instance 를 만들 때
나는 storyboard 에 해당 view controller 의 view 를 SKView 로 설정했기 때문에
알아서 새로운 SKView 의 instance 가 생성되고 present 되는 것은 아닐까?
만약 그렇다면 viewDidLoad 가 호출될까?
그럴 확률이 높다
portal view controller 에서도 알아서 viewDidLoad() 가 호출되는 것을 확인할 수 있다
그런데 그 안에서 또 새로운 view 를 생성해서 present 하고 있는데, 그럼 이것은 무한루프 하는 것 아닌가?
그럼 viewDidLoad() 의 호출 조건이 presentScene() 의 호출이 아니라는 얘기인가?

viewDidLoad() 는 storyboard 에 있는 view 가 load 된 후 호출되는 것 같다
그렇다면 내가 추가로 present(scene) 를 호출해도 viewDidLoad() 가 호출되지 않는다
단, 이미 present 중인 view 를 SKView 로
아
이거 SKScene 이 아니라 SKView 구나?
그래서 view 는 이미 있고, 나는 view 에 scene 만 present 하고 있었던 거구나?

character 는 실제 field 에 존재한다
하지만 캐릭터가 움직이는 동시에 무빙 레이어가 움직여줘야 한다
movingLayer
    field
        character
    tileMap
이동 터치는 movingLayer 가 인식하고 처리한다
드래그 이벤트가 발생한 경우 movingLayer 는 스스로의 위치를 조정한다
그러면서 character 의 위치도 수정해줘야 한다
movingLayer 가 field 에게 캐릭터를 움직이라는 메세지를 보내야할까?
movingLayer 가 캐릭터를 직접 가지고 움직여야 맞는거 아닐까?
그럼 character 는 누가 만들어야 할까?
movingLayer 가 character 를 만들고 field 에 넣어주면 될 거 같다
character node 를 class 로 만들어서 처리해도 괜찮지? 않을 것 같다
근대 이거 생각해보니 결국 드래그 터치는 moving layer 에 있을게 아니라 scene 에 있어야겠는데?
1. character move controller 를 view controller 에서 만들고 그걸 view controller 가 각 위치에 넣어주는 방법
2. 각 만들어진 것들을 가져와서 character move controller 의 값을 설정하는 방법
아니 이거 또 생각해보니 view controller 가 아니라 scene 에 넣어야 하는구만?

모든 터치는 터치 가지고 있다
LMITouch 에는 해당 터치를 위한 다양한 유용한 정보가 들어간다

class ChunkLocationMO {
    Int32   x;
    Int32   y;
    Int16   location;
}

class GameObjectMO {
    Int32   id;
    Int32   typeID;
    Int32   containerID;
    ChunkLocationMO*    chunk;
}

class TileMO {
    Int32   id;
    Int32   typeID;
    ChunkLocationMO*    chunk;
}

2023-06-06
음식
보리처럼 앞 뒤 이미지로 깊이감 있게
bounce flicked third hand item at the edge of screen
make object unstackable
애니메이션 강화
    소모, 인벤토리 들어옴 등 피드백 시
천장 구현
농사(괭이, 보리)
오브젝트를 드래그하는 상태에서 손가락을 떼지 않고 튕기면 반경 내에 그 방향으로 날라가는 상호작용
    오브젝트가 손가락에 가려지는 것을 막을 수 있다
아이템도 튕기면 날아가게
메뉴 윈도우에 도움말 추가

discord
보리, 진행바(매커니즘 진행바, 내구도 표시) 오브젝트 하단에 얇게 표시하자
월드에 입장할 때는 꿈 속에 들어가는 것 처럼 최면을 거는 듯이
    fade out fade in(시청각)
    빨려 들어가는 음악
bonus 확인하기

월드 입장 대기 화면
원하는 기능: 월드 입장, 초기화

월드 내에서의 메뉴
    월드 퇴장

저장할 데이터
타일 데이터: TileId[100][100]
타일 위의 오브젝트 데이터: GameObjectId[100][100]
캐릭터 데이터
    스킬 레벨
    인벤토리
    psychokinesis

캐릭터 원을 갈색보다 더 검은색으로 만들기

움직일 때 속도에 따른 자갈 밟는 소리
움직일 때 미세한 움직임에 부들부들 움직이면 보기 안좋을 수 있다
character node 는 ui? 에 속하도록 하자(실제 안움직임)
카메라는 실제 캐릭터가 항상 중심에 있도록 한다
isWalkable == false 인 타일 위를 움직일 때 빗겨가도록 움직이는 것을 어떻게 구현할까?
점토, 벽돌, 나무, 돌
밀가루, 벽돌, 점토, 밀, 나무, 물, 포도, 석탄
물
섬? 우주? 선택 가능
해머를 들고 상호작용 시 설치물의 내구를 파괴
고정 오브젝트 초기 맵
update 안에서 lastTime 을 0.0 이 아닌 경우에 실행하도록 하는데, 내부에서 분기가 일어나지 않도록 개선할 수 있을까?

## option
check sense message

## 맵 젠
처음 시작은 최소한의 공간을 제공한다

## 도전 과제
어떤 상호작용 등 있다는 힌트는 주지만 어떤 상호작용인지는 알려주지 않음
어떤 상호작용인지 알게 되면 베일에 감싸져 있던 아이템 혹은 상호작용이 개방

## sense message
어떤 사물에 대한 감상 뿐만 아니라 그 사물이 어떤 상호작용이 가능한지 확률적으로 출력

## 욕구 유도(동기, 목표)
어떤게 가능한지 보여주기
나라도 어떤 도구로 뭘 할 수 있는지 가능성을 알 수 있어야 그를 통해 복합적이고 창조적인 상상을 할 수 있다
그럼 어떤 도구로 뭘 할 수 있는지 어떻게 보여 줄 것인가?
그래, 뭘 할 수 있는지는 숨겨야 할 대상이 아니다
뭘 할 수 있는지만 알 수 있어도 그 새로운 활동을 하려고 시도할 것이다
꾹 누르고 있으면 그 오브젝트에 대한 description이 애플 스럽게 뜨는 것이다

## 튜토리얼 맵

미끄러지는 방식을 더 자연스럽게 만들기
메뉴 화면을 만들자
world 를 만들고 초기화할 수 있다
월드의 갯수에 제한? 이름의 설정?
버튼의 선택은 굉장히 에니메이션스럽다

## 업데이트
보이지 않는 곳도 자동으로 업데이터를 해줘야겠지?

잔디 확산 방지 시스템
돌산
광물
강물

흙 땅
작은 풀
큰 풀
    2 layer

다리는 나무 바닥
테크: 나무 -> 돌 -> 철
작업대: 어려운 아이템 제작
설명서에 조합법에는 스테이션 정보도 있어야 한다
그럼 설명서에서 그 스테이션은 어떻게 만드는지 볼 수 있었으면 좋겠다
뒤로가기는 없고 원하는 만큼 탐색을 가능하도록 구현하자

나무에서 나뭇잎, 나무 스틱 어떻게 구조화할까?
    제너럴하게 하자
    공용 인벤토리를 가지는 것은 별로다
    내가 원하는 것을 위해 원하지 않는 것도 얻어야 한다는 것은 구리다
    즉, object 마다 capacity 가 분리되어 있어야 한다
나무 스틱을 얻는 방법이 여러개인데 책은 어떤걸 올려줄까?
    랜덤하게 하지 뭐

## 컨탠츠
상호작용 정의
    터치 상호작용
        필드: 나뭇가지 생성, 나무 베기
        인벤토리: 아이템 사용
    드래그 상호작용
        아이템 옮기기
    아이템 드래그 상호작용
        필드: 건축 더미 생성
        인벤토리: 간단한 조합: 딱 2개 짜리만
        만약 옮기고 있는 오브젝트가 컨테이너 오브젝트라면 물건 옮겨 넣기
        만약 드래그 해 넣는 대상 오브젝트가 컨테이너 오브젝트라면 
        pickable 은 손이나 작업대에서 생산한다
        non-pickable 은 건축 더미로 생산한다
        건축더미는 walkable 이다
        건축더미는 스택이다
음식?
    행운의 물약: 아이템 드롭 확률 업
        하지만 노가다가 되어서는 안된다
        만들기가 쉬우면 노가다가 된다
        즉, 만들기 어려워야 한다
        의도하고 작정하고 만들기 어려울 정도로
        우연히 얻은 아이템들을 사용하다보니 만들 수 있네? 라는 느낌
    고무고무 물약: 상호작용할 수 있는 범위 확대
바닥
조합대는 9아이템까지 조합 가능
자연물은 인공물을 삭제하려는 경향을 갖음
    아이템 삭제
    자연물
        타일
            풀타일
        non-walkable 오브젝트
            나무
        walkable 오브젝트
            풀
    인공물
        자연물이 아닌 모든 것
    하지만 이 매커니즘이 너무 사람을 피곤하게 해서는 안됨


가방(2칸 ~ 25칸): 풀가방 2칸
    가장 마지막에 넣은 아이템을 보이면 좋겠다
    스택 구조이다
    상호작용 - 아이템 쓸어담기 아이템 풀어놓기
    조합대에 아이템 한 번에 옮기기
    가방 상호작용은 내가 있는 위치의 아이템을 줍는다
나무 주변에서 나뭇가지는 자연스럽게 떨어지는건 어떨까?
자연스럽게 떨어지기도 하고 직접 클릭해서 떨어뜨릴 수도 있고
그리고 거주 지역이 아닌 곳에 위치한 아이템은 확률적 소실
엄청난 꾸미기 아이템
꽃
나무
식물
    꽃, rgb 조합 가능
    새로운 꽃이 생길 때 딱 평균이 아니라 일정 범위에서 랜덤한 값 +-2 정도
동물
문
    여닫을 수도 있지만 지나가면 그냥 알아서 여닫히기도 한다

2023-06-05
# 리소스
걷는 소리
새 소리
나무 소리
조합 소리
버튼 상호작용 소리

인벤토리를 클릭하면 내가 위치한 아이템을 그 인벤토리로 옮기는 편의 기능
테마는 자연이다
너무 복잡한 자연을 구현하지는 말고 기초적인 수준으로 구현하자
모든 것이 자연스러울 수는 없다
내가 규칙을 만들고, 플레이어는 어느 정도 거기에 따라줄 수 밖에 없다
    다만 규칙이 너무 이질적이어서는 안된다
    규칙이 너무 많아서는 안된다
    규칙이 너무 복잡해서는 안된다
편집 모드, 관찰 모드

다양한 방향성
내 마음에 들고, 효율도 좋아야 한다
두 가지 방향이 있다
1. 재미 추구
2. 분재 추구
캐릭터를 클릭하면 어떻게 작동해야 할까?
캐릭터를 길게 클릭하면 스탯이 나오는거지
레어한 아이템은 좋다
    하지만 거기에 목매게 하고 싶지는 않다
    블루 우파루파, 특이한 외형의 팬더
    오로치
    이런 것들은 게임에 애정이 먼저 있어야 의미가 있다
        이게 우선이 아니다
생동감
다 재밌다 그런데 하고 싶지 않다
은둔 고수 지향
    소아온
    마비노기
    헤이븐 앤 허스
    은둔 기인
레어템의 가치
    희귀도
    전시용
    특별한 용도
조합법 O
    마인크래프트
    테라리아
    스타듀 벨리
조합법 X
레어 확률이면 숙련도가 많이 오르는거지!
씨팔 숙련도를 올려서 뭔가 다른 작업이 해금된다
필수는 아니고 유의미한 정도의 해금, 기본적으로도 가능은 하지만 선행하면 더 쉬운
숙련도가 0 만 아니면 다음 행동이 해금되는 것이다
풀 숲에서는 속도가 느려진다
제대로 된 길에서는 속도 저하가 없다
풀 숲 50%, 흙길80%, 타일이 깔린 길 100%
쓰레기통 아이템 처분

캐릭터는 하나다 월드에 귀속되지 않는다
퀄리티 표시 온오프 설정
와 씨,, 마비노기에서 가져오고 싶은게 많네
약초학
타이틀 드루이드 lv 16 이런 식으로
그래서 끝은 어떻게 할껀데? ㅋㅋ
판타지를 섞는다
기계 문명보다는 판타지가 좋다
나는 왜 여기 있는가?
내구도 durability 오브젝트들이 있다
도구, 건축물 등
업적
시간, 이동 거리 등 저장
지하는 랜덤하게 돌과 광석이 생성된다
지하는 항상 어둡다!

sense message 를 클릭하면 로그가 나오게 하자
log 와 sense message 는 구분해야 할 것 같다

품질
0, 10, 40, 90, 160, 250, 360, 1000
기본, 1.1 배, 1.2 배, 1.3 배, 1.4 배
1 + 0.1 * sqrt(품질 / 10)

영향을 미친 아이템이 많을수록 무게가 무거워진다(퀄리티가 잘 변하지 않는다)
점토 -> 점토 단지 -> 태운 점토 단지
점토 퀄, 점토 퀄, 점토 퀄 + 불 퀄
자연 타일 위에서 오브젝트가 그냥 사라지는 것이 아니라 데미지를 입는 것으로 하자

통나무에서 나무 판자를 생산할 때 통나무의 내구도를 닳게 하자
    하나의 통나무에서 하나의 나무 판자가 나오는 것은 아쉽다

캐릭터를 롱터치 -> 마스터리 정보 출력

풀에 데미지를 입기 전에 해당 오브젝트가 풀로 뒤덮힌다
풀을 상호작용해서 제거할 수 있다
256 * 256 으로 하자
건물을 파괴하면 재료를 반환한다
지하에는 기본적인 동굴도 있다
창의력을 자극함
창의력 자극은 풍부한 아이템으로 한다
오 나 이거로 이거 해보고 싶어 라는 동기 자극
그러려면 충분히 흥미로운 시스템이 갖춰져 있어야 한다
단순히 노동만 하는 것이 아니라
수 많은 꾸미기 아이템
점토 벽은 1 주
나무 벽은 4 주
돌 벽은 8 주
철 벽은 16 주
침대
책
책을 타이머처럼 쓰는건 어떨까? 50 분 마다 충전되서 진짜 책을 읽는데 도움을 주는거지
그럼 그동안 게임에 계속 접속해 있을 이유가 있나?
와! 책을 사용해서 간접 경험할 수 있도록 하자
    책을 읽으면 mastery 를 올릴 수 있는거지
    하지만 집중해서 읽을 필요가 있다. 이것을 묘사하자
    책에 아이템을 상호작용하면 그 아이템에 대한 mastery 책이 된다
    단, 10 레벨 까지만 효력이 있다
    그리고 한 번 상호작용에 무조건 1 만 오른다
    한 번 오브젝트가 설정된 책은 다른 오브젝트로 항목을 변경할 수 없다
    책은 만들기가 의외로 쉽지 않다
    오브젝트가 설정된 책은 표지에 해당 이미지가 보인다
치명타
꽃은 풀과 함께 주기적으로 리스폰된다
꽃을 교배시키면 중간 색의 꽃이 나온다
돌 바닥
나무 바닥
오브젝트끼리 상하좌우 어떤가?
처음 땅을 파면 흙이 나오고 깊은 땅을 파면 점토가 나오는거지!
얕은 물 속도 0.3
물은 7 일이면 마를 정도로 내구도가 감소한다(깊은 물과 연결되어 있지 않는 경우)
점토 양동이로 물을 퍼나를 수 있다
파인 땅은 7 일이면 다시 흙으로 메꾸어진다

## quality 떨어지는 시스템
            제작 결과가 rare 면 +10/1.1^q, common 유지, poor 이면 유지 된다
        - 사용 시 퀄리티가 1 떨어진다
        - 사용 시 rare: 감소 X, common: 0.5 감소, poor: 1.0 감소
            퀄리티가 떨어진다는 것은 재밌는 시스템이긴 하지만 스트레스가 크다
            안전이 보장되지 않기 때문이다

2023-06-03
낫, 삽, 도끼, 곡괭이, 장갑
풀 바스락 밟는 소리
    속도에 따라 빈도가 달라진다
깊은 물, 얕은 물
    깊은 물은 지나갈 수 없음
    얕은 물은 지나갈 수 있음
    다리도 건설 가능
제작 창은 필요하다
    단, 공간이 협소해지니 전체적인 ui 사이즈를 더 작게 해야겠다
최대 속력이 있으면 어떨까?
    많이 움직일 수록 최대 속력이 상승하는거지
    이동에는 제한을 두지 말자
동굴
점토
벽돌
밧줄
벽돌 구움
나무도 뻗어나
불, 어둠, 빛
스킬 포인트?
그래서 뭐함?
sense message 는 감각만 전달하고 유도하지는 말아야 한다
지하를 만든다?
섬을 만든다?
배를 만든다?
우주선을 날린다?
달을 개척한다?
삽으로 땅을 파고 물을 부어서 물 타일로 만들 수 있다
지하는 좋다

touch.location(in: self.view!) 는 값이 깔끔하게 나오는데
touch.location(in: self.camera!) 는 값이 지저분하게 나온다
하지만 화면에 적합하게 사이즈를 세팅하지 않았기 때문에
view 와 camera 가 서로 다른 단위 공간 벡터를 갖는다
당장은 오차가 다소 있어도 camera 기준으로 처리하지만,
이 문제를 해결할 아름다운 방법 생각하기

button touch 인식 방식 개선

tile 관련되서 enum 과 resource path 들을 Constant 에 다 넣어도 좋겠다

624B27 어두운 고동색
7C4D22 어두운 갈색
7F7F7F 어두운 회색
8A591E 어두운 갈색
CBCBCB 밝은 회색
E4B783 살구색

2023-05-07
다양한 화면 크기 대응
탑뷰
내 캐릭터는 타일 단위로 움직이지는 않는다
touchEnded() 에서 UITouch 의 location 값은 버리도록 하자
    이 값이 의미 있는 값을 갖는 경우 1 프레임에 값이 변한 것이기 때문에 버려도 큰 영향은 주지 않을 것이다. 그보다 사용할 경우 의미 있는 값을 갖고 있는지 판단하는 과정이 더 번거로울 것 같다
일단 이동을 단순히 구현하고 후에 디테일하게 하자
터치를 떼도 속도로 날라가고, 저항만큼 속도 감소
공부 더 필요하고 저번에 만든 코드 좀 보자
인벤은 많이는 말고 하단 마크처럼 몇 칸이 전부
멀티 터치 구현

2023-05-06
그래, 굳이 벽을 따로 만들 필요 없이 림월드나 마인크래프트처럼 벽도 타일 하나를 차지하도록 만드는 것이 복잡도 면에서 좋겠다

2023-05-05
인벤토리에서 제작하면?
그러면 아이템 내려놓는 거는 비슷하니까
안된다
버튼 효과음 뽁 입으로 녹음
움직이는 방향대로 팔을 흔드는 정도는 쉽다
하우징은 자유롭게
벽 같은 오브젝트는 인벤에 들어갈 수 없다
바닥에 설치한 것을 집을 수도 없다
파괴용 해머 좋다
타일맵으로 하자
오브젝트를 조사할 수 있다

2023-05-03 ~ 2023-05-04
propagation
주사위
어드벤처
압박하기
미니게임인데 다채로운

샌드박스는 리얼함이 포인트
rpg는 3d 정도는 되야 한다고 생각한다
가령 4 곱 4 칸이 있고 경우에 따라 순발력 있게 해당 칸을 클릭하여 문제를 해결하는 게임
우오우오우오우오우오우오우오오!
이미지 리소스는 단순하지만
패턴의 다양화로 지루하지 않다
쿵짝쿵짝쿵짝쿵짝쿵짝쿵짝쿵짝쿵-
쿵짝쿵짝쿵짝쿵짝쿵짝쿵짝쿵짝짝!
쿵짝쿵짝쿵짝쿵-쿵짝쿵짝쿵짝짝!
ㅇㅇㅇ-ㅇㅇㅇ-ㅇㅇㅇ-ㅇㅇㅇ-ㅇ-ㅇㅇㅇ-ㅇ-ㅇ
어려운 맵은 더 복잡한 배경 비트!
음악 게임도 리소스 싸움이다(이미지, 애니메이션, 사운드)
어차피 이도 저도 리소스가 많이 드는 것 같다
역시 전략 쪽으로 가야 리소스가 적게 든다(애니메이션도 필요가 없다)
만약 이 마져도 많이 든다고 생각한다면 내가 만들고 싶은 것을 조금이나마 만드는 것이 맞다
전략 퍼즐이 그나마 적은 리소스 -> 그렇다고 내가 원하지 않는 것을 만들어서는 안됨
역시 만들고 싶은건 한가한 샌드박스이다
그렇다고 석기시대부터 시작할 필요는 없다
자유!
팬으로 빠르게 돌아다니는 것을 허용
종이 그림 효과로 리소스 감소

직접 픽셀 크기를 정할 수 있게 하자
    그럼 화면은 최소 2 개
    스타트 화면과 게임 화면
블럭
    3x3 크기가 한 블럭
    블럭에 공장을 지을 수 있다

건물이 움직인다
건물을 지을 때 뽁 하는 효과
복사 붙여넣기 중요
